function atom = atom_tracking_TRH(river, nodecount, B)
% This function was written by Jon Schwenk 2014-2015
% it is for tracking meander bend 'atoms' generated by the migration_model
% Updates to the function by Tobias Hasse, tobiack@udel.edu, April 2015 
% end the need for double counting the duplicates removed variable on the 
% observation that 1 = length(n:n) for all n.  This has been updated in 
% the save_nodecount C section of migration_model_TRH as well.
%% Cut empties from input data  
for g = 1:numel(river)
    if isempty(river(g).Xcl) == 1
        keyboard
        break
    end
end
N = g-1;
river(N+1:end) = [];    % removes the unused elements
nodecount(N+1:end) = [];

%% Prepare data for node tracking
% Make a cell of cutoff indices
cud_idx{N} = []; % reserve the cell space
for y = 1:N
    cud_idx{y} = nodecount(y).A_cutoff_rem;
end
cut_indices = cud_idx; % need a copy

% Generate vector of 1 if a cutoff occurrs, else 0. Used in tracking
% algorithm. 
min_node_num = 20;
for d = 1:length(cud_idx)
    
    % remove cases where the centerline intersects itself from id'ed
    % cutoffs
    toremove=[];
    for uu = 1:2:length(cut_indices{d})
        if cut_indices{d}(uu+1) - cut_indices{d}(uu) < min_node_num
            toremove(uu) = uu;
            toremove(uu+1) = uu+1;
            didremove(d) = 1; % for auditing only
        end
    end
    toremove(toremove==0)=[];
    cut_indices{d}(toremove) = [];

    if isempty(cut_indices{d}) == 0 
        iscut(d) = 1;
    end
end

cut_time = 1:length(cut_indices);
cut_time(cellfun('isempty',cut_indices))=[];
cut_indices = cut_indices(~cellfun('isempty',cut_indices));

% Since the cutoffs locations and numbers are known, the meander cell
% length can be pre-specified.
meanders = cell(1,length(cut_indices));

% The code works in reverse time. Each cell in meanders contains a matrix
% which contains the life-cycle of a meander, starting with its "death"
% (cutoff) and working backwards to its inception. As the code marches
% forward (backward in time), it checks if another cutoff occurred at a 
% time step, and if so it begins saving that bend's life-cycle as it 
% continues.

% The real benefit of coding this backwards is that meander detection is
% much easier for cutoff meanders than when they're just forming. Because
% of thresholds etc. the code might detect a bend at one time step, but
% then not at the next, but then again at the next...and so on. Working
% backwards eliminates those complexities of detection.

%% Track atoms; compute and save their variables
% The cell 'meanders' contains the indices of each individual meander as it
% grows (or shrinks) in time. The columns represent the following:
% 1: model time
% 2,3: start and end indices of the meander

% cut_time = cut_time(12);
% cut_indices = cut_indices(12);

active_meanders = [];
stopcrit = [];
t_start = cut_time(end);

lendif_thresh = 2*B; % maximum allowed length change between two time 
                    % steps - useful for identifying when a cutoff occurs 
                    % within an bend (stops tracking at that point)
min_node_thresh = 20;   % stop tracking when bend contains fewer than  
                        % this many nodes
fraclength_thresh = 0.25; % stop tracking when the bend's length is 
                          % this threshold times its length at cutoff 

for hh = t_start:-1:2
    
%     if hh == 13898 % for debugging
%         keyboard
%     end
    
    X = river(hh).Xcl;
    Y = river(hh).Ycl;
    
    dS = sqrt(diff(X).^2+diff(Y).^2);
    cumlen = [0; cumsum(dS)];

    % Start index tracking.
    new_meander = find(hh==cut_time);
    if isempty(new_meander) == 0
        active_meanders = [active_meanders, new_meander];
        freshie = 1;
    else freshie = 0;
    end
     
    dead_meander = [];  % variable used to remove meanders from 
                        % active_meanders once criteria is met
    for bbb = 1:numel(active_meanders)
        current_meander = active_meanders(bbb);
        
        % Find the initial cutoff nodes of the meander that's being tracked
        if freshie == 1 && bbb == length(active_meanders)
            time_idx = 1;
            idx1 = cut_indices{cut_time == hh}(1); % index of upstream 
                                                   % cutoff point
            idx2 = cut_indices{cut_time == hh}(2); % index of downstream 
                                                   % cutoff point
        else
            time_idx = meanders{current_meander}(1,1) - hh + 1;% time index
            idx1 = meanders{current_meander}(time_idx-1,2);    % index of 
                                    % previous cuton, used as starting 
                                    % point for shifting the nodes
            idx2 = meanders{current_meander}(time_idx-1,3);    % index of 
                                    % previous cutoff

            % Do the index accounting to track the nodes
            if isempty(nodecount(hh).C_duplicate_rem) == 0
                for cc = size(nodecount(hh).C_duplicate_rem,1):-1:1
                   %DEBUG, test if always adding 1
%                  TRH_add_amt=length(nodecount(hh).C_duplicate_rem(cc,...
%                       1):nodecount(hh).C_duplicate_rem(cc,2));
%                  if TRH_add_amt ~= 1
%                      atom_tracking_not_adding_one_139 = [TRH_add_amt,...
%                             hh,cc]
%                  end
                    if nodecount(hh).C_duplicate_rem(cc,1) < idx1
                        %TRH I believe the next line will always evaluate
                        %to idx1+1 which means C_duplicate_rem does not
                        %need to have double entries of all the nodes
                        idx1 = idx1 + 1; 
                        %TRH length(nodecount(hh).C_duplicate_rem(cc,1):...
%                             nodecount(hh).C_duplicate_rem(cc,2));
                    end
                    if nodecount(hh).C_duplicate_rem(cc,1) < idx2
                        idx2 = idx2 + 1; 
                        %TRH length(nodecount(hh).C_duplicate_rem(cc,1):...
%                             nodecount(hh).C_duplicate_rem(cc,2));
                    end
                end
            end
            
            if isempty(nodecount(hh).B_spacing_ins) == 0
                for bb1 = size(nodecount(hh).B_spacing_ins,1):-1:1 % had 
                  % to break into two loops to use the "break" command a 
                  % few lines down. need to treat idx1 and idx2 separately.
                    if nodecount(hh).B_spacing_ins(bb1,1) < idx1 - 1
                        idx1 = idx1 - 1;
                    elseif nodecount(hh).B_spacing_ins(bb1,1) == idx1 - 1 
                        % when the removed node is the one being tracked
%                         keyboard
                        % find the closest node:
                        [~,idx1] = min(sqrt((river(hh+1).Xcl(idx1)-X).^...
                            2+(river(hh+1).Ycl(idx1)-Y).^2)); 
                        break % this is because we don't want to shift the 
                              % nodes anymore after finding the closest one
                              % at the next time step
                    end
                end
                for bb2 = size(nodecount(hh).B_spacing_ins,1):-1:1
                    if nodecount(hh).B_spacing_ins(bb2,1) < idx2 - 1
                        idx2 = idx2 - 1;
                    elseif nodecount(hh).B_spacing_ins(bb2,1) == idx2 - 1 
                        % when the removed node is the one being tracked
%                         keyboard
                        % find the closest node:
                        [~,idx2] = min(sqrt((river(hh+1).Xcl(idx2)-X).^...
                            2+(river(hh+1).Ycl(idx2)-Y).^2)); 
                        break
                    end
                end
            end
            
            if isempty(nodecount(hh).A_cutoff_rem) == 0
                for aa = 1:2:size(nodecount(hh).A_cutoff_rem,2)
                    if nodecount(hh).A_cutoff_rem(aa) <= idx1
                        idx1 = idx1 + ...
length(nodecount(hh).A_cutoff_rem(aa):nodecount(hh).A_cutoff_rem(aa+1))-2;
                    end
                    if nodecount(hh).A_cutoff_rem(aa) <= idx2
                        idx2 = idx2 + ...
length(nodecount(hh).A_cutoff_rem(aa):nodecount(hh).A_cutoff_rem(aa+1))-2;
                    end
                end
            end
        end
        
        idx1 = min(idx1,numel(X));
        idx2 = min(idx2,numel(X));
        
        % Does the bend meet certain criteria?
        current_len = cumlen(idx2)-cumlen(idx1); % compute length

        if  time_idx > 1 % need at least two points for comparison
            if current_len - meanders{current_meander}(time_idx-1,4) > ...
                    lendif_thresh  % was there a large jump in length?
                dead_meander = [dead_meander,bbb];
                stopcrit = [stopcrit 2];
            elseif idx2 - idx1 < min_node_thresh % are there enough nodes?
                dead_meander = [dead_meander,bbb];
                stopcrit = [stopcrit 3];
                
            % If none of the stopping criteria are met, save bend stats
            else
              meander_nodes(bbb,:) = [idx1,idx2];
              meanders{current_meander}(time_idx,4) = NaN; % preallocate 
              meanders{current_meander}(time_idx,1) = hh; %saves sim time
              % first cutoff index:
              meanders{current_meander}(time_idx,2) = meander_nodes(bbb,1); 
              % second cutoff index
              meanders{current_meander}(time_idx,3) = meander_nodes(bbb,2); 
              meanders{current_meander}(time_idx,4) = current_len; % length
            end 
        else
            meander_nodes(bbb,:) = [idx1,idx2];
            meanders{current_meander}(time_idx,4) = NaN; % preallocate 
            % the array (the next lines are the most time consuming, I 
            % assume because the cell must be rewritten each element)
            meanders{current_meander}(time_idx,1) = hh; % saves time
            meanders{current_meander}(time_idx,2) = meander_nodes(bbb,1); 
            meanders{current_meander}(time_idx,3) = meander_nodes(bbb,2); 
            meanders{current_meander}(time_idx,4) = current_len; % length
        end
    end
    active_meanders(dead_meander) = []; % removes meanders from processing 
                                    % once they've met criteria for removal
    
    if rem(hh,2000) == 0
        disp([num2str(hh/t_start*100), '% extraction remaining']);
    end
end

%% Change cell to a struct. 
% Note the name is also changed from meanders to bend
N = numel(meanders);
atom(N).t = [];
atom(N).idx1 = [];
atom(N).idx2 = [];
atom(N).len = [];

for o = 1:numel(meanders)
    if isempty(meanders{o}) == 0
    atom(o).t = meanders{o}(:,1);
    atom(o).idx1 = meanders{o}(:,2);
    atom(o).idx2 = meanders{o}(:,3);
    atom(o).len = meanders{o}(:,4);
    end
end

%% Post-extraction filtering, i.e. filter bends based on criteria that 
% can't easily be checked while building meanders cell
min_time_steps = 2000; % Remove bends whose lifespans are too short
% frac_dist_from_head = 0.2; % fraction of the entire channel length at 
                        % which an bend must be beyond to be considered a 
                        % cutoff (avoiding upstream edge effects)
% timeatsteady = 3000/.2;   % number of time steps until model 
                            % reached steady state 

to_remove = [];
for d = 1:numel(atom)
    to_remove(d) = 0;
    if isempty(atom(d).t) == 1 
        to_remove(d) = 4;
    elseif atom(d).t(1) - atom(d).t(end) < min_time_steps % remove bends 
                                        % that don't persist long enough
            to_remove(d) = 1;
%     elseif bend(d).idx2(1) == numel(river(bend(d).t(1)).Xcl); 
    % remove bends formed at the downstream-most portion of the centerline
%             to_remove(d) = 2;
%     elseif bend(d).t(end) < timeatsteady
%             to_remove(d) = 5;
%     else
%             dS = rivC(bend(d).t(end)).dS; % remove bends that are too 
                    % close to the upstream-most node (avoid edge effects)
%             [frac_index,~] = find((cumsum(dS) - sum(dS) * ...
%                 frac_dist_from_head) > 0, 1, 'first');
%             if bend(d).idx1(1) < frac_index
%                 to_remove(d) = 3;
%             end
        
    end
end
atom(to_remove>0) = [];
fprintf(['you have reached the end of atom_tracking_TRH.m, \n',...
    'type "dbcont" to continue'])
keyboard
